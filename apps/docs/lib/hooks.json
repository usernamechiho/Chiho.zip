[
  {
    "id": 1,
    "title": "useBattery",
    "description": "Fetches and monitors device battery level and charging state.",
    "content": "import { useEffect, useState } from \"react\";\n\n\ntype BatteryManager = {\n  level: number;\n  charging: boolean;\n  chargingTime: number;\n  dischargingTime: number;\n  addEventListener(\n    type: string,\n    listener: EventListener | EventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListener | EventListenerObject | null,\n    options?: boolean | EventListenerOptions,\n  ): void;\n};\n\ntype BatteryState = {\n  supported: boolean;\n  loading: boolean;\n  level: number | null;\n  charging: boolean | null;\n  chargingTime: number | null;\n  dischargingTime: number | null;\n};\n\ntype NavigatorWithBattery = Navigator & {\n  getBattery?: () => Promise<BatteryManager>;\n};\n\n/**\n * Fetches and monitors device battery level and charging state.\n *\n * @description Provides battery information including level, charging status, and estimated time for charging and discharging.\n * Handles unsupported environments by setting `supported` to `false`.\n *\n * @returns {BatteryState} - An object with battery state properties:\n * - `supported` {boolean}: Indicates if the Battery API is supported.\n * - `loading` {boolean}: True while fetching initial battery data.\n * - `level` {number | null}: Battery level as a decimal (0.0 to 1.0), or null if unavailable.\n * - `charging` {boolean | null}: Whether the battery is currently charging, or null if unavailable.\n * - `chargingTime` {number | null}: Estimated time in seconds until fully charged, or null if unavailable.\n * - `dischargingTime` {number | null}: Estimated time in seconds until battery is depleted, or null if unavailable.\n */\nexport function useBattery() {\n  const [batteryState, setBatteryState] = useState<BatteryState>({\n    supported: true,\n    loading: true,\n    level: null,\n    charging: null,\n    chargingTime: null,\n    dischargingTime: null,\n  });\n\n  useEffect(() => {\n    const _navigator = navigator as NavigatorWithBattery;\n    let battery: BatteryManager | null = null;\n\n    /**\n     * Updates the battery state when a battery property changes.\n     */\n    const handleBatteryChange = () => {\n      if (battery) {\n        setBatteryState({\n          supported: true,\n          loading: false,\n          level: battery.level,\n          charging: battery.charging,\n          chargingTime: battery.chargingTime,\n          dischargingTime: battery.dischargingTime,\n        });\n      }\n    };\n\n    if (!_navigator.getBattery) {\n      setBatteryState((prevState) => ({\n        ...prevState,\n        supported: false,\n        loading: false,\n      }));\n      return;\n    }\n\n    _navigator\n      .getBattery()\n      .then((_battery) => {\n        battery = _battery;\n        handleBatteryChange();\n        battery.addEventListener(\"levelchange\", handleBatteryChange);\n        battery.addEventListener(\"chargingchange\", handleBatteryChange);\n        battery.addEventListener(\"chargingtimechange\", handleBatteryChange);\n        battery.addEventListener(\"dischargingtimechange\", handleBatteryChange);\n      })\n      .catch(() => {\n        setBatteryState((prevState) => ({\n          ...prevState,\n          supported: false,\n          loading: false,\n        }));\n      });\n\n    return () => {\n      if (battery) {\n        battery.removeEventListener(\"levelchange\", handleBatteryChange);\n        battery.removeEventListener(\"chargingchange\", handleBatteryChange);\n        battery.removeEventListener(\"chargingtimechange\", handleBatteryChange);\n        battery.removeEventListener(\n          \"dischargingtimechange\",\n          handleBatteryChange,\n        );\n      }\n    };\n  }, []);\n\n  return batteryState;\n}\n"
  },
  {
    "id": 2,
    "title": "useClipboard",
    "description": "Provides a function to copy text to the clipboard effortlessly.",
    "content": "import { useEffect, useState } from \"react\";\n\n\n/**\n * React hook to copy a given text to the user's clipboard.\n *\n * @param {number} [timeout=1500] Time in milliseconds to show the \"copied\"\n * success state after a successful copy action.\n *\n * @returns {object} An object with two properties:\n * - `isCopied`: A boolean indicating whether the text was successfully copied\n *   to the user's clipboard.\n * - `copy`: A function that takes a string argument and attempts to copy it to\n *   the user's clipboard. If the copy action is successful, it sets the\n *   `isCopied` state to `true`.\n */\nexport function useClipboard(timeout = 1500) {\n  const [isCopied, setIsCopied] = useState(false);\n\n  useEffect(() => {\n    let timer: ReturnType<typeof setTimeout>;\n\n    if (isCopied) {\n      timer = setTimeout(() => {\n        setIsCopied(false);\n      }, timeout);\n    }\n\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [isCopied, timeout]);\n\n  /**\n   * Attempts to copy the given text to the user's clipboard.\n   *\n   * If the copy action is successful, it sets the `isCopied` state to `true`.\n   * If the copy action fails, it logs an error to the console and\n   * displays a native alert with the message \"Failed to copy text\".\n   *\n   * If the browser does not support the Clipboard API, it displays a\n   * native alert with the message \"Copy not supported\".\n   *\n   * @param {string} text The text to copy to the user's clipboard.\n   */\n  const copy = (text: string) => {\n    if (navigator.clipboard && window.isSecureContext) {\n      navigator.clipboard\n        .writeText(text)\n        .then(() => {\n          setIsCopied(true);\n        })\n        .catch((err: unknown) => {\n          console.error(\"Failed to copy: \", err);\n          alert(\"Failed to copy text\");\n        });\n    } else {\n      alert(\"Copy not supported\");\n    }\n  };\n\n  return { isCopied, copy };\n}\n"
  },
  {
    "id": 3,
    "title": "useCountDown",
    "description": "Implements countdown functionality with configurable options.",
    "content": "import { useCallback, useEffect, useState } from \"react\";\n\n\ntype CountdownOptions = {\n  countStart: number;\n  intervalMs?: number;\n  countStop?: number;\n};\n\ntype CountdownControllers = {\n  startCountdown: () => void;\n  stopCountdown: () => void;\n  resetCountdown: () => void;\n};\n\n/**\n * Implements countdown functionality with configurable options.\n *\n * @param {CountdownOptions} options - The options for the countdown.\n * @param {number} options.countStart - The starting count value.\n * @param {number} [options.countStop=0] - The count value at which the countdown stops.\n * @param {number} [options.intervalMs=1000] - The interval in milliseconds at which the countdown updates.\n * @returns {[number, CountdownControllers]} - A tuple containing the current count and countdown controllers.\n */\nexport function useCountdown({\n  countStart,\n  countStop = 0,\n  intervalMs = 1000,\n}: CountdownOptions): [number, CountdownControllers] {\n  const [count, setCount] = useState(countStart);\n  const [isRunning, setIsRunning] = useState(false);\n  const [timer, setTimer] = useState<ReturnType<typeof setInterval> | null>(\n    null,\n  );\n\n  const startCountdown = useCallback(() => {\n    if (!isRunning) {\n      setIsRunning(true);\n    }\n  }, [isRunning]);\n\n  const stopCountdown = useCallback(() => {\n    if (timer) {\n      clearInterval(timer);\n      setTimer(null);\n    }\n    setIsRunning(false);\n  }, [timer]);\n\n  const resetCountdown = useCallback(() => {\n    stopCountdown();\n    setCount(countStart);\n  }, [stopCountdown, countStart]);\n\n  useEffect(() => {\n    if (isRunning) {\n      setTimer(\n        setInterval(() => {\n          setCount((prevCount) => {\n            if (prevCount <= countStop) {\n              stopCountdown();\n              return countStop;\n            }\n            return prevCount - 1;\n          });\n        }, intervalMs),\n      );\n    }\n\n    return () => {\n      if (timer) {\n        clearInterval(timer);\n      }\n    };\n  }, [isRunning, intervalMs, countStop, stopCountdown]);\n\n  return [count, { startCountdown, stopCountdown, resetCountdown }];\n}\n"
  },
  {
    "id": 4,
    "title": "useCountUp",
    "description": "Implements count-up functionality with customizable settings.",
    "content": "import { useCallback, useEffect, useState } from \"react\";\n\n\ntype CountupOptions = {\n  countStart: number;\n  intervalMs?: number;\n  countStop?: number;\n};\n\ntype CountupControllers = {\n  startCountup: () => void;\n  stopCountup: () => void;\n  resetCountup: () => void;\n};\n\n/**\n * Implements count-up functionality with customizable settings.\n *\n * @param {CountupOptions} options - The options for the count-up.\n * @param {number} options.countStart - The starting count value.\n * @param {number} [options.countStop=Infinity] - The count value at which the count-up stops.\n * @param {number} [options.intervalMs=1000] - The interval in milliseconds at which the count-up updates.\n * @returns {[number, CountupControllers]} - A tuple containing the current count and count-up controllers.\n */\nexport function useCountup({\n  countStart,\n  countStop = Infinity,\n  intervalMs = 1000,\n}: CountupOptions): [number, CountupControllers] {\n  const [count, setCount] = useState(countStart);\n  const [isRunning, setIsRunning] = useState(false);\n  const [timer, setTimer] = useState<ReturnType<typeof setInterval> | null>(\n    null,\n  );\n\n  const startCountup = useCallback(() => {\n    if (!isRunning) {\n      setIsRunning(true);\n    }\n  }, [isRunning]);\n\n  const stopCountup = useCallback(() => {\n    if (timer) {\n      clearInterval(timer);\n      setTimer(null);\n    }\n    setIsRunning(false);\n  }, [timer]);\n\n  const resetCountup = useCallback(() => {\n    stopCountup();\n    setCount(countStart);\n  }, [stopCountup, countStart]);\n\n  useEffect(() => {\n    if (isRunning) {\n      setTimer(\n        setInterval(() => {\n          setCount((prevCount) => {\n            if (prevCount >= countStop) {\n              stopCountup();\n              return countStop;\n            }\n            return prevCount + 1;\n          });\n        }, intervalMs),\n      );\n    }\n\n    return () => {\n      if (timer) {\n        clearInterval(timer);\n      }\n    };\n  }, [isRunning, intervalMs, countStop, stopCountup]);\n\n  return [count, { startCountup, stopCountup, resetCountup }];\n}\n"
  },
  {
    "id": 5,
    "title": "useCounter",
    "description": "Returns a tuple with counter value and increment, decrement, reset functions.",
    "content": "import { useCallback, useMemo, useState } from \"react\";\n\nimport type { Dispatch, SetStateAction } from \"react\";\n\ntype CounterReturnType = {\n  increment: () => void;\n  decrement: () => void;\n  reset: () => void;\n  count: number;\n  setCount: Dispatch<SetStateAction<number>>;\n};\n\n\n/**\n * Returns a tuple with counter value and increment, decrement, reset functions.\n *\n * - `increment`: A function that increments the counter by 1.\n * - `decrement`: A function that decrements the counter by 1.\n * - `reset`: A function that sets the counter to 0.\n * - `count`: The current value of the counter.\n * - `setCount`: A state setter function that sets the counter to the given\n *   value.\n *\n * The hook takes an optional `initialValue` parameter which sets the initial\n * value of the counter. If not provided, the counter is initialized to 0.\n *\n * @param {number} [initialValue] Optional initial value of the counter.\n * @returns {CounterReturnType}\n */\nexport function useCounter(initialValue?: number): CounterReturnType {\n  const [count, setCount] = useState(initialValue ?? 0);\n\n  const increment = useCallback(() => {\n    setCount((x) => x + 1);\n  }, []);\n  const decrement = useCallback(() => {\n    setCount((x) => x - 1);\n  }, []);\n  const reset = useCallback(() => {\n    setCount(initialValue ?? 0);\n  }, [initialValue]);\n\n  const returnObject = useMemo(\n    () => ({\n      increment,\n      decrement,\n      reset,\n      count,\n      setCount,\n    }),\n    [increment, decrement, reset, count, setCount],\n  );\n\n  return returnObject;\n}\n"
  },
  {
    "id": 6,
    "title": "useDebounceCallback",
    "description": "Debounces a callback, executing it only after a specified delay.",
    "content": "import { useCallback, useEffect, useRef } from \"react\";\n\n\n/**\n * Debounces a callback, executing it only after a specified delay.\n *\n * @param {Function} callback - The callback function to debounce.\n * @param {number} delay - The debounce delay in milliseconds.\n * @returns {Function} - A debounced version of the callback function.\n *\n * @example\n * const debouncedSave = useDebounceCallback((value) => {\n *   console.log(\"Saving data:\", value);\n * }, 500);\n */\nexport function useDebounceCallback<T extends (...args: unknown[]) => void>(\n  callback: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  const timer = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const debouncedCallback = useCallback(\n    (...args: Parameters<T>) => {\n      if (timer.current) {\n        clearTimeout(timer.current);\n      }\n\n      timer.current = setTimeout(() => {\n        callback(...args);\n      }, delay);\n    },\n    [callback, delay],\n  );\n\n  useEffect(() => {\n    return () => {\n      if (timer.current) {\n        clearTimeout(timer.current);\n      }\n    };\n  }, []);\n\n  return debouncedCallback;\n}\n"
  },
  {
    "id": 7,
    "title": "useDebounceValue",
    "description": "Debounces a value, updating it after a specified delay.",
    "content": "import { useEffect, useState } from \"react\";\n\n\n/**\n * Debounces a value, updating it after a specified delay.\n * Useful for cases where you want to prevent frequent updates (e.g., input fields).\n *\n * @template T - The type of the value being debounced.\n * @param {T} value - The value to debounce.\n * @param {number} delay - The debounce delay in milliseconds.\n * @returns {T} - The debounced value.\n *\n * @example\n * const debouncedSearchTerm = useDebounceValue(searchTerm, 500);\n * // The debouncedSearchTerm will update 500ms after the last change in searchTerm.\n */\nexport function useDebounceValue<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n"
  },
  {
    "id": 8,
    "title": "useDevice",
    "description": "Detects device type and returns a boolean for each detected type.",
    "content": "import { useSyncExternalStore } from \"react\";\n\ntype DeviceDetect = {\n  isMobile: boolean;\n  isDesktop: boolean;\n  isTablet: boolean;\n  DesktopView: () => boolean;\n  MobileView: () => boolean;\n  TabletView: () => boolean;\n};\n\n\n// Device type is constant and never changes\nconst emptySubscribe = () => () => {};\n\nconst getDeviceTypeClient = (): DeviceDetect => {\n  const userAgent = navigator.userAgent;\n  let deviceType = \"desktop\";\n  if (/tablet/i.test(userAgent)) {\n    deviceType = \"tablet\";\n  } else if (/mobile/i.test(userAgent)) {\n    deviceType = \"mobile\";\n  }\n  const isMobile = deviceType === \"mobile\";\n  const isDesktop = deviceType === \"desktop\";\n  const isTablet = deviceType === \"tablet\";\n\n  const DesktopView = () => isDesktop;\n  const MobileView = () => isMobile;\n  const TabletView = () => isTablet;\n\n  return {\n    isMobile,\n    isDesktop,\n    isTablet,\n    DesktopView,\n    MobileView,\n    TabletView,\n  };\n};\n\nconst getDeviceTypeServer = (): DeviceDetect => ({\n  isMobile: false,\n  isDesktop: true,\n  isTablet: false,\n  DesktopView: () => true,\n  MobileView: () => false,\n  TabletView: () => false,\n});\n\n/**\n * Detects device type and returns a boolean for each detected type.\n *\n * @returns {DeviceDetect} - An object containing boolean values for each device type.\n */\nexport function useDevice(): DeviceDetect {\n  return useSyncExternalStore(\n    emptySubscribe,\n    getDeviceTypeClient,\n    getDeviceTypeServer,\n  );\n}\n"
  },
  {
    "id": 9,
    "title": "useEventCallback",
    "description": "Returns a memoized callback that remains stable across renders.",
    "content": "import { useCallback, useEffect, useRef } from \"react\";\n\n\n/**\n * Returns a memoized callback that remains stable across renders.\n *\n * @param fn The callback function that depends on external values.\n * @returns A stable version of the provided callback.\n */\nexport function useEventCallback<T extends (...args: unknown[]) => void>(\n  fn: T,\n): T {\n  const ref = useRef<T>(fn);\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback(((...args) => ref.current(...args)) as T, []);\n}\n"
  },
  {
    "id": 10,
    "title": "useEventListener",
    "description": "Adds and cleans up an event listener on a specified target element.",
    "content": "import { useEffect, useRef } from \"react\";\n\nimport type { RefObject } from \"react\";\n\n\n/**\n * Adds and cleans up an event listener on a specified target element.\n *\n * @param eventName The event type (e.g. 'click', 'scroll', 'resize', etc.).\n * @param handler The event handler function.\n * @param element Optional: The target element to attach the event listener to (defaults to window).\n */\nexport function useEventListener<K extends keyof WindowEventMap>(\n  eventName: K,\n  handler: (event: WindowEventMap[K]) => void,\n  element?: RefObject<HTMLElement> | Window,\n): void {\n  const savedHandler = useRef<(event: WindowEventMap[K]) => void>(handler);\n\n  // Update the ref.current value if the handler changes\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    const targetElement: HTMLElement | Window =\n      element && \"current\" in element && element.current\n        ? element.current\n        : window;\n\n    if (!targetElement) return;\n\n    // Type assertion is added here to ensure TypeScript understands the event type correctly\n    const eventListener: EventListener = (event) => {\n      savedHandler.current(event as WindowEventMap[K]);\n    };\n\n    targetElement.addEventListener(eventName, eventListener);\n\n    return () => {\n      targetElement.removeEventListener(eventName, eventListener);\n    };\n  }, [eventName, element]);\n}\n"
  },
  {
    "id": 11,
    "title": "useFetch",
    "description": "Fetches data from a specified API endpoint.",
    "content": "import { useCallback, useEffect, useState } from \"react\";\n\ntype UseFetchResult<T, E> = {\n  data: T | null;\n  error: E | null;\n  isPending: boolean;\n  isSuccess: boolean;\n  isError: boolean;\n  refetch: () => void;\n};\n\n\n/**\n * Fetches data from a specified API endpoint.\n *\n * @template T - Type of the data returned by the API.\n * @template E - Type of the error returned by the API (default is `string`).\n *\n * @param {string} url - The URL of the API endpoint.\n * @param {RequestInit} [reqOpt] - Optional configuration for the fetch request (e.g., method, headers).\n *\n * @returns {UseFetchResult<T, E>} An object containing the following properties:\n * - `data`: The data returned by the API, or `null` if no data has been received yet.\n * - `error`: The error returned by the API, or `null` if no error has occurred.\n * - `isPending`: A boolean indicating whether the fetch request is currently in progress.\n * - `isSuccess`: A boolean indicating if the fetch request was successful.\n * - `isError`: A boolean indicating if the fetch request resulted in an error.\n * - `refetch`: A function to manually trigger the fetch request again.\n */\nexport function useFetch<T, E = string>(\n  url: string,\n  reqOpt?: RequestInit,\n): UseFetchResult<T, E> {\n  const [data, setData] = useState<T | null>(null);\n  const [error, setError] = useState<E | null>(null);\n  const [isPending, setisPending] = useState(false);\n  const [isSuccess, setIsSuccess] = useState(false);\n\n  /**\n   * Fetches data from the provided URL using the specified request options.\n   *\n   * This function uses `fetch` with an `AbortController` to allow for request cancellation if needed.\n   * Updates the state with the response data, error, or loading status based on the fetch result.\n   */\n  const fetchData = useCallback(async () => {\n    setisPending(true);\n    setIsSuccess(false);\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    try {\n      const res = await fetch(url, { ...reqOpt, signal });\n      const result = await res.json();\n\n      if (res.ok) {\n        setData(result);\n        setIsSuccess(true);\n        setError(null);\n      } else {\n        setError(result as E);\n      }\n    } catch (e) {\n      if (e instanceof Error && e.name !== \"AbortError\") {\n        setError(e as unknown as E);\n      }\n    } finally {\n      setisPending(false);\n    }\n\n    return () => {\n      controller.abort();\n    };\n  }, [url, reqOpt]);\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  return {\n    data,\n    error,\n    isPending,\n    isSuccess,\n    isError: !isSuccess && !isPending,\n    refetch: fetchData,\n  };\n}\n"
  },
  {
    "id": 12,
    "title": "useFocus",
    "description": "Tracks the focus state of a specified element.",
    "content": "import { useEffect, useRef, useState } from \"react\";\n\nimport type { RefObject } from \"react\";\n\ntype UseFocusCallback = (isFocused: boolean) => void;\n\n\n/**\n * Tracks the focus state of a specified element.\n *\n * Optionally takes a callback function which is called whenever the element\n * gains or loses focus. The callback is called with a boolean indicating\n * whether the element is currently focused.\n *\n * @param callback Optional callback to run in focus and blur HTML element mode\n * @returns A tuple containing the ref and a boolean indicating whether the\n * element is currently focused.\n */\nexport function useFocus<T extends HTMLElement>(\n  callback?: UseFocusCallback,\n): [RefObject<T>, boolean] {\n  const [isFocused, setIsFocused] = useState(false);\n  const ref = useRef<T>(null);\n\n  useEffect(() => {\n    /**\n     * A function to run whenever the element gains focus.\n     * @param {boolean} isFocused - Whether the element is currently focused.\n     * @param {UseFocusCallback} [callback] - The callback function provided to useFocus.\n     */\n    const handleFocus = () => {\n      setIsFocused(true);\n      callback?.(true);\n    };\n    /**\n     * A function to run whenever the element loses focus.\n     * @param {boolean} isFocused - Whether the element is currently focused.\n     * @param {UseFocusCallback} [callback] - The callback function provided to useFocus.\n     */\n    const handleBlur = () => {\n      setIsFocused(false);\n      callback?.(false);\n    };\n\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(\"focus\", handleFocus);\n      node.addEventListener(\"blur\", handleBlur);\n    }\n\n    return () => {\n      if (node) {\n        node.removeEventListener(\"focus\", handleFocus);\n        node.removeEventListener(\"blur\", handleBlur);\n      }\n    };\n  }, [callback]);\n\n  return [ref, isFocused];\n}\n"
  },
  {
    "id": 13,
    "title": "useHover",
    "description": "Tracks the hover state of a specified element.",
    "content": "import { useEffect, useRef, useState } from \"react\";\n\n\n/**\n * Adds an event listener to a given target.\n *\n * @param eventType - The type of event to listen for.\n * @param listener - The event handler function.\n * @param target - The target to which the event listener will be attached.\n */\nfunction useEventListener<K extends keyof HTMLElementEventMap>(\n  eventType: K,\n  listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => void,\n  target: React.RefObject<HTMLElement>,\n): void {\n  useEffect(() => {\n    const element = target.current;\n    if (!element) return;\n\n    element.addEventListener(eventType, listener);\n    return () => {\n      element.removeEventListener(eventType, listener);\n    };\n  }, [eventType, listener, target]);\n}\n\n/**\n * Tracks the hover state of a specified element.\n *\n * @returns A tuple containing a ref to attach to the element and a boolean indicating if it's hovered.\n */\nexport function useHover<T extends HTMLElement>(): [\n  React.RefObject<T>,\n  boolean,\n] {\n  const [isHovered, setIsHovered] = useState(false);\n  const ref = useRef<T>(null);\n\n  const handleMouseEnter = () => {\n    setIsHovered(true);\n  };\n  const handleMouseLeave = () => {\n    setIsHovered(false);\n  };\n\n  useEventListener(\"mouseenter\", handleMouseEnter, ref);\n  useEventListener(\"mouseleave\", handleMouseLeave, ref);\n\n  return [ref, isHovered];\n}\n"
  },
  {
    "id": 14,
    "title": "useInterval",
    "description": "Sets up an interval with imperative controls. Returns start/stop methods and running state.",
    "content": "import { useEffect, useRef, useState } from \"react\";\n\n\ntype IntervalOptions = {\n  immediate?: boolean;\n  autoStart?: boolean;\n};\n\ntype IntervalReturn = {\n  start: () => void;\n  stop: () => void;\n  toggle: () => void;\n  isRunning: boolean;\n};\n\n/**\n * Sets up an interval with imperative controls. Returns start/stop methods and running state.\n *\n * @template {() => void} T - Function type for the interval callback\n * @param {T} callback - Function to execute at each interval tick (automatically uses latest version)\n * @param {number | null} delay - Interval delay in milliseconds (null to clear interval)\n * @param {IntervalOptions} [options] - Optional configuration for the interval\n *\n * - `immediate`: If true, the callback function will be executed immediately after the interval starts (default: false)\n * - `autoStart`: If true, the interval will start automatically (default: true)\n *\n * @returns {IntervalReturn} An object containing the following properties:\n * - `start`: A function to start the interval.\n * - `stop`: A function to stop the interval.\n * - `toggle`: A function to toggle the interval on and off.\n * - `isRunning`: A boolean indicating whether the interval is currently running.\n */\nexport function useInterval(\n  callback: () => void,\n  delay: number | null,\n  options?: IntervalOptions,\n): IntervalReturn {\n  const savedCallback = useRef(callback);\n  const { immediate = false, autoStart = true } = options ?? {};\n  const [isRunning, setIsRunning] = useState(autoStart);\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    if (typeof delay !== \"number\" || !isRunning) return;\n    if (immediate) {\n      savedCallback.current();\n    }\n\n    const tick = () => savedCallback.current();\n    const id = setInterval(tick, delay);\n    return () => clearInterval(id);\n  }, [delay, isRunning, immediate]);\n\n  const start = () => setIsRunning(true);\n  const stop = () => setIsRunning(false);\n  const toggle = () => setIsRunning(!isRunning);\n\n  return { start, stop, toggle, isRunning };\n}\n"
  },
  {
    "id": 15,
    "title": "useIsClient",
    "description": "Determines if the component is rendered on the client side.",
    "content": "import { useEffect, useState } from \"react\";\n\n\n/**\n * Determines if the component is rendered on the client side.\n *\n * @returns {boolean} - Returns true if the component is mounted on the client, false otherwise.\n */\nexport function useIsClient(): boolean {\n  const [isClient, setClient] = useState<boolean>(false);\n\n  useEffect(() => {\n    setClient(true);\n  }, []);\n\n  return isClient;\n}\n"
  },
  {
    "id": 16,
    "title": "useIsMounted",
    "description": "Returns a function to check if the component is currently mounted.",
    "content": "import { useEffect, useRef } from \"react\";\n\n\ntype UseIsMountedReturnType = () => boolean;\n\n/**\n * A Returns a function to check if the component is currently mounted.\n *\n * This hook can be useful for preventing state updates on unmounted components,\n * which can lead to memory leaks and errors in your application.\n *\n * @returns {Function} A function that returns a boolean indicating whether the component is mounted.\n */\nexport function useIsMounted(): UseIsMountedReturnType {\n  const isMounted = useRef<boolean>(false);\n\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return () => isMounted.current;\n}\n"
  },
  {
    "id": 17,
    "title": "useIsmorphicLayoutEffect",
    "description": "Conditionally invokes useLayoutEffect on the server and useEffect on the client.",
    "content": "import { useEffect, useLayoutEffect } from \"react\";\n\n\n/**\n * Conditionally invokes useLayoutEffect on the server and useEffect on the client.\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n"
  },
  {
    "id": 18,
    "title": "useKeyPress",
    "description": "Detects the press state of a specified key.",
    "content": "import { useEffect, useState } from \"react\";\n\ntype KeyConfig = {\n  key: string;\n  ctrl?: boolean;\n  alt?: boolean;\n  shift?: boolean;\n  meta?: boolean;\n};\n\n\n/**\n * Key configuration object for the useKeyPress hook.\n *\n * @typedef {Object} KeyConfig\n * @property {string} key - The key to listen for.\n * @property {boolean} [ctrl] - Whether the Ctrl key must be pressed. Optional.\n * @property {boolean} [alt] - Whether the Alt key must be pressed. Optional.\n * @property {boolean} [shift] - Whether the Shift key must be pressed. Optional.\n */\n\n/**\n * Detects the press state of a specified key.\n *\n * @param {KeyConfig} config - The configuration for the key press detection.\n * @returns {boolean} - A boolean value indicating whether the specified key combination is currently pressed.\n *\n * @example\n * // Usage:\n * const isEnterPressed = useKeyPress({ key: \"Enter\" });\n * const isCtrlSPressed = useKeyPress({ key: \"s\", ctrl: true });\n */\n\nexport function useKeyPress(config: KeyConfig): boolean {\n  const [keyPressed, setKeyPressed] = useState(false);\n  const { key: targetKey, ctrl, alt, shift, meta } = config;\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    const { key, ctrlKey, altKey, shiftKey, metaKey } = e;\n\n    if (\n      (!ctrl && !alt && !shift && key === targetKey) ||\n      (ctrl && key === targetKey && ctrlKey === ctrl) ||\n      (alt && key === targetKey && altKey === alt) ||\n      (shift && key === targetKey && shiftKey === shift) ||\n      (meta && key === targetKey && metaKey === meta)\n    ) {\n      setKeyPressed(true);\n    }\n  };\n\n  const handleKeyUp = (e: KeyboardEvent) => {\n    const { key, ctrlKey, altKey, shiftKey, metaKey } = e;\n\n    if (\n      (!ctrl && !alt && !shift && key === targetKey) ||\n      (ctrl && key === targetKey && ctrlKey === ctrl) ||\n      (alt && key === targetKey && altKey === alt) ||\n      (shift && key === targetKey && shiftKey === shift) ||\n      (meta && key === targetKey && metaKey === meta)\n    ) {\n      setKeyPressed(false);\n    }\n  };\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", handleKeyDown);\n    window.addEventListener(\"keyup\", handleKeyUp);\n\n    return () => {\n      window.removeEventListener(\"keydown\", handleKeyDown);\n      window.removeEventListener(\"keyup\", handleKeyUp);\n    };\n  }, []);\n\n  return keyPressed;\n}\n"
  },
  {
    "id": 19,
    "title": "useLang",
    "description": "Returns the user’s current browser language based on their settings.",
    "content": "import { useSyncExternalStore } from \"react\";\n\n\n/**\n * Subscribes to the `languagechange` event on the `window` object to detect changes in the user's preferred language.\n * This function returns an unsubscribe function to remove the event listener.\n *\n * @param {() => void} callback - The callback function that triggers when the language changes.\n * @returns {() => void} A function to unsubscribe from the `languagechange` event.\n */\nfunction langSubscribe(callback: () => void) {\n  window.addEventListener(\"languagechange\", callback);\n  return () => {\n    window.removeEventListener(\"languagechange\", callback);\n  };\n}\n\n/**\n * Retrieves the current language of the user's browser.\n *\n * @returns {string} The current language code (e.g., 'en-US', 'fr', etc.).\n */\nconst getLang = (): string => navigator.language;\n\n/**\n * Returns the user’s current browser language based on their settings.\n *\n * @returns {string} The current browser language.\n */\nexport function useLang(): string {\n  return useSyncExternalStore(langSubscribe, getLang);\n}\n"
  },
  {
    "id": 20,
    "title": "useLocalStorage",
    "description": "Manages a state variable synchronized with local storage.",
    "content": "import { useEffect, useState } from \"react\";\n\n\n/**\n * Manages a state variable synchronized with local storage.\n *\n * @param {string} key - The key for the local storage item.\n * @param {T} initialValue - The initial value for the state variable.\n * @returns {[T, (value: T) => void]} An array containing the state variable and a setter function.\n *\n * @example\n * const [name, setName] = useLocalStorage('name', 'John Doe');\n * // The name variable will be persisted in local storage under the key 'name'.\n */\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T,\n): [T, (value: T) => void] {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading local storage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  const setValue = (value: T) => {\n    try {\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting local storage key \"${key}\":`, error);\n    }\n  };\n\n  useEffect(() => {\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === key) {\n        setStoredValue(\n          event.newValue ? JSON.parse(event.newValue) : initialValue,\n        );\n      }\n    };\n\n    window.addEventListener(\"storage\", handleStorageChange);\n\n    return () => {\n      window.removeEventListener(\"storage\", handleStorageChange);\n    };\n  }, [key, initialValue]);\n\n  return [storedValue, setValue];\n}\n"
  },
  {
    "id": 21,
    "title": "useMap",
    "description": "Provides a reactive Map instance with common mutation methods for state management.",
    "content": "import { useCallback, useState } from \"react\";\n\n\ntype MapActions<K, V> = {\n  /**\n   * Sets a key-value pair in the map\n   * @param key - Map key to set\n   * @param value - Value to associate with the key\n   */\n  set: (key: K, value: V) => void;\n\n  /**\n   * Deletes a key from the map\n   * @param key - Map key to remove\n   * @returns true if the key existed and was removed\n   */\n  delete: (key: K) => boolean;\n\n  /** Clears all entries from the map */\n  clear: () => void;\n\n  /**\n   * Initializes/replaces the entire map contents\n   * @param entries - Iterable of key-value pairs to initialize the map\n   */\n  initialize: (entries: Iterable<[K, V]>) => void;\n};\n\n/**\n * Creates a reactive Map instance with mutation methods for state updates.\n * @template K - Type of map keys\n * @template V - Type of map values\n * @param {Iterable<[K, V]>} [initialEntries] - Initial map entries (optional)\n * @returns {[ReadonlyMap<K, V>, MapActions<K, V>]} Tuple containing:\n * - Current map state (readonly)\n * - Object with map mutation methods\n */\nexport function useMap<K, V>(\n  initialEntries?: Iterable<[K, V]> | (() => Iterable<[K, V]>),\n): [ReadonlyMap<K, V>, MapActions<K, V>] {\n  const [map, setMap] = useState(() => {\n    const entries =\n      typeof initialEntries === \"function\" ? initialEntries() : initialEntries;\n    return new Map(entries);\n  });\n\n  const set = useCallback((key: K, value: V) => {\n    setMap((prev) => {\n      const next = new Map(prev);\n      next.set(key, value);\n      return next;\n    });\n  }, []);\n\n  const deleteFn = useCallback((key: K) => {\n    let didDelete = false;\n    setMap((prev) => {\n      const next = new Map(prev);\n      didDelete = next.delete(key);\n      return next;\n    });\n    return didDelete;\n  }, []);\n\n  const clear = useCallback(() => {\n    setMap(new Map());\n  }, []);\n\n  const initialize = useCallback((entries: Iterable<[K, V]>) => {\n    setMap(new Map(entries));\n  }, []);\n\n  return [map, { set, delete: deleteFn, clear, initialize }];\n}\n"
  },
  {
    "id": 22,
    "title": "usePrevious",
    "description": "Tracks the previous value of a variable. Returns the previous value on every render.",
    "content": "import { useEffect, useRef } from \"react\";\n\n\n/**\n * Tracks the previous value of a variable. Returns the previous value on every render.\n *\n * @template T - The type of the value being tracked.\n * @param {T} value - The current value to track.\n * @returns {T | undefined} - The previous value, or `undefined` on the initial render.\n *\n */\nexport function usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n"
  },
  {
    "id": 23,
    "title": "useScroll",
    "description": "Tracks and returns the current scroll position, with a method to scroll to specific coordinates.",
    "content": "import { useLayoutEffect, useState } from \"react\";\n\n\n/**\n * Represents the scroll position in the x and y directions.\n */\ntype ScrollPosition = {\n  x: number;\n  y: number;\n};\n\n/**\n * Tracks and returns the current scroll position, with a method to scroll to specific coordinates.\n *\n * @returns {{ position: ScrollPosition; scrollTo: (options: ScrollToOptions) => void }}\n */\nexport function useScroll(): {\n  position: ScrollPosition;\n  scrollTo: (options: ScrollToOptions) => void;\n} {\n  const [position, setPosition] = useState<ScrollPosition>({\n    x: 0,\n    y: 0,\n  });\n\n  const handleScroll = () => {\n    if (typeof window !== \"undefined\") {\n      setPosition({\n        x: window.scrollX,\n        y: window.scrollY,\n      });\n    }\n  };\n\n  useLayoutEffect(() => {\n    if (typeof window !== \"undefined\") {\n      setPosition({\n        x: window.scrollX,\n        y: window.scrollY,\n      });\n\n      window.addEventListener(\"scroll\", handleScroll);\n\n      return () => {\n        window.removeEventListener(\"scroll\", handleScroll);\n      };\n    }\n  }, []);\n\n  const scrollTo = (options: ScrollToOptions) => {\n    if (typeof window !== \"undefined\") {\n      window.scrollTo(options);\n    }\n  };\n\n  return {\n    position,\n    scrollTo,\n  };\n}\n"
  },
  {
    "id": 24,
    "title": "useSessionStorage",
    "description": "Manages a state variable synchronized with session storage.",
    "content": "import { useEffect, useState } from \"react\";\n\n\n/**\n * Manages a state variable synchronized with session storage.\n *\n * @param {string} key - The key for the session storage item.\n * @param {T} initialValue - The initial value for the state variable.\n * @returns {[T, (value: T) => void]} An array containing the state variable and a setter function.\n *\n * @example\n * const [name, setName] = useSessionStorage('name', 'John Doe');\n * // The name variable will be persisted in session storage under the key 'name'.\n */\nexport function useSessionStorage<T>(\n  key: string,\n  initialValue: T,\n): [T, (value: T) => void] {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.sessionStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading session storage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  const setValue = (value: T) => {\n    try {\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.sessionStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting session storage key \"${key}\":`, error);\n    }\n  };\n\n  useEffect(() => {\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === key) {\n        setStoredValue(\n          event.newValue ? JSON.parse(event.newValue) : initialValue,\n        );\n      }\n    };\n\n    window.addEventListener(\"storage\", handleStorageChange);\n\n    return () => {\n      window.removeEventListener(\"storage\", handleStorageChange);\n    };\n  }, [key, initialValue]);\n\n  return [storedValue, setValue];\n}\n"
  },
  {
    "id": 25,
    "title": "useSleep",
    "description": "Resolves after a specified delay.",
    "content": "import { useCallback } from \"react\";\n\n\n/**\n * Resolves after a specified delay.\n * @param {number} ms - The number of milliseconds to wait before resolving.\n * @returns {Promise<void>} - A promise that resolves after the specified delay.\n *\n */\nexport function useSleep(): (ms: number) => Promise<void> {\n  return useCallback((ms: number): Promise<void> => {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }, []);\n}\n"
  },
  {
    "id": 26,
    "title": "useStatus",
    "description": "Returns the current online/offline status of the client.",
    "content": "import { useSyncExternalStore } from \"react\";\n\n\n/**\n * Custom hook that returns the current online/offline status of the client.\n * Optionally, takes a callback function to be invoked whenever the status changes.\n *\n * @param {function} callback - Optional callback to run on status change.\n * @returns {boolean} - `true` if online, `false` if offline.\n */\nexport function useStatus(callback?: (isOnline: boolean) => void): boolean {\n  return useSyncExternalStore(\n    (cb) => {\n      const abortController = new AbortController();\n      window.addEventListener(\n        \"online\",\n        () => {\n          cb();\n          callback?.(true);\n        },\n        { signal: abortController.signal },\n      );\n      window.addEventListener(\n        \"offline\",\n        () => {\n          cb();\n          callback?.(false);\n        },\n        {\n          signal: abortController.signal,\n        },\n      );\n      return () => {\n        abortController.abort();\n      };\n    },\n    () => navigator.onLine,\n    () => true,\n  );\n}\n"
  },
  {
    "id": 27,
    "title": "useStep",
    "description": "Manages step-based navigation with imperative controls. Returns step navigation methods and state.",
    "content": "import { useCallback, useEffect, useMemo, useState } from \"react\";\n\n\ntype UseStepProps<T = number> = {\n  totalSteps?: number;\n  steps?: T[];\n  initialStep?: T;\n};\n\ntype UseStepReturn<T> = {\n  currentStep: T;\n  nextStep: () => void;\n  prevStep: () => void;\n  jumpTo: (step: T) => void;\n  isFirstStep: boolean;\n  isLastStep: boolean;\n};\n\n/**\n * Manages step-based navigation with imperative controls. Returns step navigation methods and state.\n *\n * @template T - Type for step identifiers (default: number)\n * @param {Object} config - Configuration object for step management\n * @param {number} [config.totalSteps] - Total number of steps (required if steps not provided)\n * @param {T[]} [config.steps] - Array of custom step identifiers (required if totalSteps not provided)\n * @param {T} [config.initialStep] - Initial step identifier (defaults to first step)\n *\n * @returns {UseStepReturn<T>} An object containing:\n * - `currentStep`: Currently active step identifier\n * - `nextStep`: Advances to the next step if available\n * - `prevStep`: Returns to the previous step if available\n * - `jumpTo`: Jumps directly to a specific step identifier\n * - `isFirstStep`: True if current step is the first step\n * - `isLastStep`: True if current step is the final step\n */\n\nexport function useStep<T = number>(config: UseStepProps<T>): UseStepReturn<T> {\n  const {\n    totalSteps: totalStepsConfig,\n    steps: stepsConfig,\n    initialStep,\n  } = config;\n\n  if (!stepsConfig && !totalStepsConfig) {\n    throw new Error(\"You must provide either steps or totalSteps\");\n  }\n\n  const steps = useMemo(\n    () =>\n      stepsConfig ??\n      Array.from(\n        { length: totalStepsConfig ?? 0 },\n        (_, i) => (i + 1) as unknown as T,\n      ),\n    [stepsConfig, totalStepsConfig],\n  );\n\n  const totalSteps = steps.length;\n  const initialIndex = steps.indexOf(initialStep as T);\n  const safeInitialIndex = initialIndex !== -1 ? initialIndex : 0;\n\n  const [currentIndex, setCurrentIndex] = useState<number>(safeInitialIndex);\n\n  useEffect(() => {\n    setCurrentIndex((prev) => Math.max(0, Math.min(prev, totalSteps - 1)));\n  }, [totalSteps]);\n\n  const nextStep = useCallback(() => {\n    setCurrentIndex((prev) => Math.min(prev + 1, totalSteps - 1));\n  }, [totalSteps]);\n\n  const prevStep = useCallback(() => {\n    setCurrentIndex((prev) => Math.max(prev - 1, 0));\n  }, []);\n\n  const jumpTo = useCallback(\n    (step: T) => {\n      const newIndex = steps.indexOf(step);\n      if (newIndex !== -1) {\n        setCurrentIndex(newIndex);\n      }\n    },\n    [steps],\n  );\n\n  const isFirstStep = currentIndex === 0;\n  const isLastStep = currentIndex === totalSteps - 1;\n\n  return {\n    currentStep: steps[currentIndex],\n    nextStep,\n    prevStep,\n    jumpTo,\n    isFirstStep,\n    isLastStep,\n  };\n}\n"
  },
  {
    "id": 28,
    "title": "useThrottle",
    "description": "Returns a throttled version of the provided function.",
    "content": "import { useCallback, useEffect, useRef } from \"react\";\n\n\n/**\n * Type for throttle options\n * @typedef {Object} ThrottleOptions\n * @property {number} [wait=300] - The number of milliseconds to throttle invocations to\n * @property {boolean} [leading=true] - Specify invoking on the leading edge of the timeout\n * @property {boolean} [trailing=true] - Specify invoking on the trailing edge of the timeout\n */\n\ntype ThrottleOptions = {\n  wait?: number;\n  leading?: boolean;\n  trailing?: boolean;\n};\n\n/**\n * Returns a throttled version of the provided function.\n * The throttled function will only execute at most once per every `wait` milliseconds.\n *\n * @template T - Generic type extending function\n * @param {T} fn - The function to throttle\n * @param {ThrottleOptions} [options] - The configuration options\n * @param {number} [options.wait=300] - The number of milliseconds to throttle invocations to\n * @param {boolean} [options.leading=true] - If true, the function will execute on the leading edge of the timeout\n * @param {boolean} [options.trailing=true] - If true, the function will execute on the trailing edge of the timeout\n *\n * @returns {(...args: Parameters<T>) => void} A throttled version of the provided function\n */\nexport function useThrottle<T extends (...args: unknown[]) => void>(\n  fn: T,\n  options: ThrottleOptions = {},\n): (...args: Parameters<T>) => void {\n  const { wait = 300, leading = true, trailing = true } = options;\n\n  const timeoutRef = useRef<number | null>(null);\n  const lastRunRef = useRef<number>(0);\n  const lastArgsRef = useRef<Parameters<T> | null>(null);\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current !== null) {\n        window.clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return useCallback(\n    (...args: Parameters<T>) => {\n      const now = Date.now();\n      const elapsed = now - lastRunRef.current;\n\n      lastArgsRef.current = args;\n\n      const execute = () => {\n        if (lastArgsRef.current) {\n          fn(...lastArgsRef.current);\n        }\n        lastRunRef.current = Date.now();\n      };\n\n      if (timeoutRef.current !== null) {\n        window.clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n\n      if (elapsed > wait) {\n        if (leading) {\n          execute();\n        } else if (trailing) {\n          timeoutRef.current = window.setTimeout(execute, wait);\n        }\n      } else if (trailing) {\n        timeoutRef.current = window.setTimeout(execute, wait - elapsed);\n      }\n    },\n    [fn, wait, leading, trailing],\n  );\n}\n"
  },
  {
    "id": 29,
    "title": "useTitle",
    "description": "Changes the page title dynamically.",
    "content": "import { useState } from \"react\";\n\n\n/**\n * Changes the page title dynamically.\n *\n * @description Provides a stateful title and a function to update both the state and the document title.\n *\n * @returns {Object} - An object containing:\n * - `title` {string}: The current page title.\n * - `changeTitle` {(newTitle: string) => void}: Function to update the page title.\n */\n\nexport function useTitle() {\n  const [title, setTitle] = useState<string>(document.title);\n\n  /**\n   * Updates the document title and internal title state.\n   *\n   * @param {string} newTitle - The new title to set for the page.\n   */\n  const changeTitle = (newTitle: string) => {\n    setTitle(newTitle);\n    document.title = newTitle;\n  };\n\n  return { title, changeTitle };\n}\n"
  },
  {
    "id": 30,
    "title": "useToggle",
    "description": "Returns a stateful value with two functions to update it.",
    "content": "import { useCallback, useState } from \"react\";\n\nimport type { Dispatch, SetStateAction } from \"react\";\n\n\n/**\n * Returns a stateful value with two functions to update it.\n *\n * @param defaultValue - The initial value of the state. Defaults to `false`.\n *\n * @returns A tuple containing:\n * - `boolean`: The current value of the state.\n * - `() => void`: A function to toggle the state.\n * - `Dispatch<SetStateAction<boolean>>`: A function to set the state to a new value.\n */\nexport function useToggle(\n  defaultValue?: boolean,\n): [boolean, () => void, Dispatch<SetStateAction<boolean>>] {\n  const [value, setValue] = useState(!!defaultValue);\n\n  const toggle = useCallback(() => {\n    setValue((x) => !x);\n  }, []);\n\n  return [value, toggle, setValue];\n}\n"
  },
  {
    "id": 31,
    "title": "useUnmount",
    "description": "Executes a callback function when the component unmounts.",
    "content": "import { useEffect, useRef } from \"react\";\n\n\n/**\n * Executes a callback function when the component unmounts.\n *\n * @param {() => void} fn - The callback function to be executed on unmount.\n */\nexport function useUnmount(fn: () => void): void {\n  const fnRef = useRef<() => void>(fn);\n\n  useEffect(() => {\n    fnRef.current = fn;\n\n    return () => {\n      fnRef.current();\n    };\n  }, [fn]);\n}\n"
  },
  {
    "id": 32,
    "title": "useWindowSize",
    "description": "Tracks and returns the current window size.",
    "content": "import { useSyncExternalStore } from \"react\";\n\ntype WindowSize = {\n  width: number;\n  height: number;\n};\n\n\nconst subscribeToResizeEvent = (cb: () => void) => {\n  window.addEventListener(\"resize\", cb);\n  return () => {\n    window.removeEventListener(\"resize\", cb);\n  };\n};\n\nconst getWindowSizeClient = () => ({\n  width: window.innerWidth,\n  height: window.innerHeight,\n});\n\n// on the server window is undefined, so assume FullHD screen\nconst getWindowSizeServer = () => ({\n  width: 1920,\n  height: 1080,\n});\n\n/**\n * Tracks and returns the current window size.\n * @returns {WindowSize} An object containing the current width and height of the window.\n */\nexport function useWindowSize(): WindowSize {\n  return useSyncExternalStore(\n    subscribeToResizeEvent,\n    getWindowSizeClient,\n    getWindowSizeServer,\n  );\n}\n"
  }
]